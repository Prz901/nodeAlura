var nextTick = require("../../../runtime/nextTick");

function AsyncValue() {
    /**
     * The data that was provided via call to resolve(data).
     * This property is assumed to be public and available for inspection.
     */
    this.r_ = undefined;

    /**
     * The data that was provided via call to reject(err)
     * This property is assumed to be public and available for inspection.
     */
    this.s_ = undefined;

    /**
     * The queue of callbacks that are waiting for data
     */
    this.t_ = undefined;

    /**
     * The state of the data holder (STATE_INITIAL, STATE_RESOLVED, or STATE_REJECTED)
     */
    this.u_ = false;
}

function notifyCallbacks(asyncValue, err, value) {
    var callbacks = asyncValue.t_;
    if (callbacks) {
        // clear out the registered callbacks (we still have reference to the original value)
        asyncValue.t_ = undefined;

        // invoke all of the callbacks and use their scope
        for (var i = 0; i < callbacks.length; i++) {
            // each callback is actually an object with "scope and "callback" properties
            var callback = callbacks[i];
            callback(err, value);
        }
    }
}

AsyncValue.prototype = {
    /**
     * Adds a callback to the queue. If there is not a pending request to load data
     * and we have a "loader" then we will use that loader to request the data.
     * The given callback will be invoked when there is an error or resolved data
     * available.
     */
    v_: function (callback) {
        // Do we already have data or error?
        if (this.u_) {
            // invoke the callback immediately
            return callback(this.s_, this.r_);
        }

        var callbacks = this.t_ || (this.t_ = []);
        callbacks.push(callback);
    },

    /**
     * This method will trigger any callbacks to be notified of rejection (error).
     * If this data holder has a loader then the data holder will be returned to
     * its initial state so that any future requests to load data will trigger a
     * new load call.
     */
    w_: function (err) {
        if (this.u_) {
            return;
        }

        // remember the error
        this.s_ = err;

        // Go to the rejected state if we don't have a loader.
        // If we do have a loader then return to the initial state
        // (we do this so that next call to done() will trigger load
        // again in case the error was transient).
        this.u_ = true;

        // always notify callbacks regardless of whether or not we return to the initial state
        notifyCallbacks(this, err, null);
    },

    /**
     * This method will trigger any callbacks to be notified of data.
     */
    x_: function (value) {
        if (this.u_) {
            return;
        }

        if (value && typeof value.then === "function") {
            var asyncValue = this;

            var finalPromise = value.then(function onFulfilled(value) {
                nextTick(asyncValue.x_.bind(asyncValue, value));
            }, function onRejected(err) {
                nextTick(asyncValue.w_.bind(asyncValue, err));
            });

            if (finalPromise.done) {
                finalPromise.done();
            }
        } else {
            // remember the state
            this.r_ = value;

            // go to the resolved state
            this.u_ = true;

            // notify callbacks
            notifyCallbacks(this, null, value);
        }
    }
};

module.exports = AsyncValue;